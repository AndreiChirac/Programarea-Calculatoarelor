In ceea ce priveste aceasta tema am incercat sa realizez pentru fiecare task cate un subprogram care sa fie flexibil , sa functioneze pe un plan mai larg, nu doar pentru adresele din enuntul temei. 
Pentru inceput am ales sa imi citesc numarul care imi va indica cate seturi de date voi primi, ca mai apoi sa deschid o instructiune repetitiva de tip “for” in care imi va incepe citirea ip-urilor si a mastilor,dar si construirea lor cu ajutorul operatiilor pe biti(pentru fiecare valoare citita am siftat fiecare componenta cu 24,16,8 in functie de  pozitie pentru a obtine adresa de ip doar din 1 si 0 fara puncte intre octeti  ), respectiv a sirului de adrese de date , realizat cu un alt “for” cu ajutorul caruia am putut citi si salva in 2 vectori ceea ce aveam nevoie pentru solutionarea taskurilor.
Pentru inceput am spus ca este necesar sa realizez o functie care sa mi constuiasca masca deoarece am vazut ca ulteroior sunt cerinte care imi necesita acest lucru(Subprogramul fiind bazat tot pe ideea de shiftare a bitilor , am umplut cu atati de 1 in fata cu cat imi specifica numarul zecimal oferit si cu 0 restul. )
Pentru taskul 0, am considerat ca este mult mai util sa realizez afisarea din moment ce am variabile ce au stocate deja valorile numerice .
Pentru taskul 1 ,am realizat un subprogram care imi preia un numar valid pentru construirea unei masti de retea si imi afiseaza forma ei zecimala pe 4 octeti (am folosit subprogramul de constructie amintit anterior )
Pentru taskul 2, la fel ca in taskul 0, am considerat ca este o abordare mai simpla si mai usor de urmarit sa implementez printarea mastii in baza 8 si 16 (cu ajutorul %o si %x) direct in main tinand cont ca avem variabile care tin minte valorile din masca .
Pentru taskul 3, am realizat o functie care sa mi preia ca parametrii un ip si o masca si sa mi realizeze procedeul de si logic intre cele doua . Acest pocedeu fiind considerat pe cate 8 biti (se incepe siftarea din dreapta pentru fiecare componenta si se realizeaza un si logic atat intre ele cat si cu nr 255 care reprezinta 8 biti de cate 1 pentru a afla forma zecimala )
Pentru taskul 4, mai intai mi am construit complementul mastii(cu ajutorul conceptului de a nega si a subprogramului de constructie a unei masti ) si apoi am realizat procedeul de sau logic pe biti intre ip complementul mastii care la randul lor se sifteaza la dreapta si se realizaeaza si logic cu nr 255 pentru a putea afisa zecimal  .
Pentru cel de al 5 lea task, nu am facut altceva decat sa imi fac adresele de retea pentru ip1 si ip2 si sa le compar . 
Pentru taskul 6 am luat o variabila semafor si am  observat ca o masca este gresita in momentul primei aparitii a lui 0 urmate de un 1 asa ca am folosit conceptul de get the bit si in momentul in care gaseam o succesiune cu biti ca cei amintiti anterior variabila sa-mi se faca 0  si sa nu mai caute in continuare . Tot acest proces a fost realizat intr un subprogram care returneaza ok astfel voi sti ce sa afisez Da pentru ok=1 si Nu pt ok=0. 
Pentru taskul al 7 lea ,mi am construit un subprogram care sa imi preia pozitia in care s a aflat eroarea de succesiune a lui 0 de 1 si un altul care daca prin apelarea functiei descrisa la taskul 6 imi va afisa masca sau o va corecta . Corectarea se realizeaza prin umplerea cu 0 a mastii de la pozitia pe care a gasit o subprogramul amintit. 
Pentru taskul 8, am folosit conceptul get the bit, 
Iar la fiecare 8 pozitii parcurse sa imi puna punct decat daca nu se afla pe ultima pozitie din ip .
Pentru taskul 9, am realizat 2 subprograme unul care imi va aplica o masca pe un ip si cel de al doilea care imi va compara cele 2 rezultate si va returna 1 sau 0 in functie de compatibilitatea celor 2 adrese.
